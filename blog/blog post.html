
<h4>unfinished</h4>


<p>Hello! Walker the Intern here. Today's post will [...]</p>

<p>This code is still in progress, so the end result here is not production-ready, but we hope exposing the process in this way is helpful to any others who might be thinking about utilizing tests in their own archival coding.</p>


<h4>What is a test?</h4>
<p>A test is code you write to check that another piece of code you have written is doing what you expect it to be doing.</p>
<p>If I had some function called normalize_date that turned a human-inputted date, say "Jan. 21, 1991" into a machine-readable format, like "1991-01-21", its test might look something like this:</p>

<pre class="brush: python; toolbar: false">
assert normalize_date("Jan. 21, 1991") == "1991-01-21"
</pre>

<p>This would fail if the normalized version did not match expected outcome, leaving a helpful error message as to what went wrong and where.</p>

<h4>So what is TDD?</h4>
<p>Test-Driven Development is a methodology / philosophy for writing code used almost ubiquitously in the world of agile software design. At its most base level it can be distilled into a three-step cyclic process: write a failing test -> quickly write the simplest code you can to make the test pass -> refactor. Where one might naturally be inclined to write code then test it, TDD reverses this process, putting the tests first
</p>

<h4>What does this have to do with archives?
</h4>
<p>In our work on EAD transformation we commonly deal with tens of thousands of messy fields that require
</p>
with decades of changing local practice, largely translated from human-readable word doc finding aids


<h4>What about the overhead?</h4>

<p>The Bentley's EADs represent over 80 years and countless hours of work on the part of the staff and students who were involved in their creation. The last thing we want to do while automating our xml normalizations is make an unintended change that nullifies the work of those who came before us. Since uncertainty is always a factor when working with messy data, it is remarkably easy for small innocuous code changes to have unintended and unanticipated side-effects. If one mistake can potentially nullify hundreds of hours of work, then the few hours it takes to write the tests is well worth the investment, and is actually saving time in the long-run.<p>

<h4>Learn by doing - building an extent parser in python with TDD</h4>

<p>That's a lot of talk, but what does it look like in practice? As Max described in a <a href="http://archival-integration.blogspot.com/2015/05/extentuating-circumstances-80-years-of.html">recent blog post</a>, one of our current projects involves wrestling with verbose and varied extent statements, trying to coerce them into a format that ArchivesSpace can read properly. Since it's on our minds, let's see if we can use TDD to build a script for parsing a long combined extent statement into its component parts.</p>

<p>The remainder of this post will be pretty python heavy, but even if you're not familiar with programming languages python is unusually readable, so follow along and I think you'll be surprised at how much it makes sense!</p>

<p>To start off, remember TDD mantra: test first, code later. So, let's make a new file to hold all our test code (we'll call it <em>tests.py</em>) and start with something simple:</p>

<pre class="brush: python; toolbar: false">
# first, we'll define the original extent statement, something we
# might find in an average EAD &lt;extent&gt; tag
basic_extent_raw_text = "4 linear feet and 1 oversize volume."

# then let's define the list of objects we want to transform that into
basic_extent_target_output = ["4 linear feet", "1 oversize volume"]

# run the (currently unwritten) code to transform the input text,
# and store the result in a new variable
split_extent_text = split_extents(basic_extent_raw_text)

# test whether the result is exactly equal to our desired output
assert split_extent_text == basic_extent_target_output
</pre>
<br>
<p>now run it and...</p>

<p><img src="http://i.imgur.com/GmPd5Lg.png" style="width:100%"/></p>

<p>Ta-da! We have written our first failing test.</p>

<p>So now what? Now we find the path of least resistance - the easiest way we can think of to solve the given error. The console suggests that a "split_extents" function doesn't exist, so let's make one! Over in a new extent_splitter.py file, let's write</p>

<pre class="brush: python; toolbar: false">
def split_extents(basic_extent_raw_text):
    pass
</pre>
<br>
<p>Function created! Before we can test it, tests.py needs to know where to find the split_extents function, so let's make sure the test script can find it by importing the split_extents function:</p>

<pre class="brush: python; toolbar: false">
from extent_splitter import split_extents
</pre>
<br>
<p>Now run the test again, and see where that leads us:</p>

<p><img src="http://i.imgur.com/H9nIQPe.png" style="width:100%"/></p>

<p>Our assert statement is failing, meaning that split_extent_text is not equal to our target output. This isn't surprising considering split_extents isn't actually returning anything yet. Let's fix the assert error as simply as we can:</p>

<pre class="brush: python; toolbar: false">
def split_extents(extent_text):
    return ["4 linear feet", "1 oversize volume"]
</pre>
<br>
<p>There! It's cheesiest of fixes (the code doesn't actually do anything with the input string, it just cheekily returns the list we want), but it really is important to do these small, path-of-least-resistance edits, especially as we are just learning the concept of TDD. Small iterative steps keeps code manageable and easy to conceptualize as you build it -- it can be all too easy to get carried away and add a whole suite of functionality in one rushed clump, only to have the code fail at runtime and not have any idea where the problem lies.</p>

<p>So now we have a completely working test! Normally at this point we would take a step back to refactor what we have written, but there really isn't much there, and the code doesn't do anything remotely useful. We can easily break it again by adding another simple test case: </p>

<pre class="brush: python; toolbar: false">
extent_2_raw_text = "1 oversize volume and 5 motion picture reels"
extent_2_target_output = ["1 oversize volume", "5 motion picture reels"]
split_extent_text = split_extents(extent_2_raw_text)
assert split_extent_text == extent_2_target_output
</pre>
<br>
<p>This test fails, so we have code to write! Writing custom pre-built lists for each possible extent is a terrible plan, so let's write something actually useful:</p>

<pre class="brush: python; toolbar: false">
def split_extents(extent_text):
    text_split = extent_text.split(" and ")
    return text_split
</pre>
<br>
<p>Run the test, and... Success! Again, here we would refactor, but this code is still simple enough it isn't necessary. Now that we have two tests, we have a new problem: how do we keep track of which is which, or know which is failing when the console returns an error? </p>
<p>Luckily for us, python has a built-in module for testing that can take care of the background test management and let us focus on just writing the code. The one thing to note is that using the module requires putting the tests in a python class, which functions slightly differently than the functions you may be used to. All that you really have to know is that you will need to pre-append any variable you want to use throughout the class with "self.", and include "self" as a variable to any function you define inside the class. Here is what our tests look like using unittest as a framework:</p>

<pre class="brush: python; toolbar: false">
import unittest  # Python's testing module
from extent_splitter import split_extents  # import the function we're testing

class TestExtentSplitter(unittest.TestCase):

    # "setUp" is a special reserved function that is used to define any
    # variables you will be using throughout the test. It runs before
    # anything else in the class.

    def setUp(self):
        self.extent_1_raw_text = "4 linear feet and 1 oversize volume."
        self.extent_1_target_output = ["4 linear feet", "1 oversize volume"]
        self.extent_2_raw_text = "1 oversize volume and 5 motion picture reels"
        self.extent_2_target_output = ["1 oversize volume", "5 motion picture reels"]

    # Now for the tests. We will define each discrete test in its own
    # function. You want to be as specific as possible when creating test
    # names - this is really invaluable when figuring out exactly which
    # tests are failing, and what was being tested when they failed.

    # All tests need to start with "test" for the class to run properly

    def test_split_first_two_element_extent_string(self):
        split_extent = split_extents(self.extent_1_raw_text)
        self.assertEquals(split_extent, self.extent_1_target_output)

    def test_split_second_two_element_extent_string(self):
        split_extent = split_extents(self.extent_2_raw_text)
        self.assertEquals(split_extent, self.extent_2_target_output)

# code to have the tests run if this file is called from the command-line
if __name__ == "__main__":
    unittest.main()
</pre>
<br>
<p>You can run the tests just like you would any other python script. Let's try it and see what happens:</p>

<p>[image of successful test run]</p>

<p>Now we have a function that splits any sentence that has " and " in it. But many extent statements have more than two elements. These tend to be separated by commas, so let's write a test to see if it handles a longer extent statement properly. Over in setUp, we'll define two new variables:</p>

<pre class="brush: python; toolbar: false">
self.extent_with_commas_raw_text = "3 linear ft., 1 oversize volume, and 5 motion picture reels"
self.extent_with_commas_target_output = ["3 linear ft.", "1 oversize volume", "5 motion picture reels"]
</pre>
<br>
<p>Then we'll write the test:</p>
<pre class="brush: python; toolbar: false">
def test_split_extent_with_commmas(self):
    split_extent_text = split_extents(self.extent_with_commas_raw_text)
    assert split_extent_text == self.extent_with_commas_target_output
</pre>
<br>
<p>Tests fail, so let's get coding.</p>
<pre class="brush: python; toolbar: false">
def split_extents(extent_text):
    text_split = extent_text.split(" and ")

    extent_list = []
    # now that the sentence is split by "and", let's split each
    # of the two resulting items by commas, appending the result to
    # a new list
    for extent in text_split:
        extent_list.append(extent.split(","))

    # Now we have a list containing two lists: [['3 linear ft.', '1 oversize volume', ''], ['5 motion picture reels']]
    # We need to flatten it down to one list
    extent_list_2 = []
    for extent_list in discrete_item_list:
        for extent in extent_list:
            extent_list_2.append[extent]

    return filter(None, extent_list_2) # the filter method here gets rid of empty strings
</pre>
<br>
<p>Now the tests pass, but this code is super ugly - time to refactor! Let's go back through and see if we can clean things up a bit.</p>

<p>It turns out, we can reproduce the above functionality in just two lines, using what are known as <em>list comprehensions</em>:</p>

<pre class="brush: python; toolbar: false">
def split_extents(extent_text):
    extents = extent_text.split(",")
    extents = filter(None, [item for extent in extents for item in extent.split(" and ")])
    return extents
</pre>

<p>[talk about commenting in planned tests, and filling them in one by one. Need to know the variety and scope of content you're dealing with]</p>

<p>Repeat this process a few more times and we have something that could really be useful. It didn't add all that much extra time, we can easily change the code without worrying if the change broke some obscure edge case, and we can have confidence that the code we've written is doing exactly what it is supposed to be doing</p>

<p>The complete test suite:</p>
<pre class="brush: python; toolbar: false">
    [code]
</pre>

<br>

<p>The extent splitting script:</p>
<pre class="brush: python; toolbar: false">
    [code]
</pre>